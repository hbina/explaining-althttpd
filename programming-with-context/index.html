<!doctype html><html lang=en><meta charset=utf-8><head><title>Programming with Context</title><body><section class=section><div class=container><div><h1 class=title>Programming with Context</h1><p class=subtitle><strong></strong><hr><h2 id=disclaimer>Disclaimer</h2><p>This is just my understanding of the subject. It is by no mean correct or even "educated" per se. It's just the things that caught my mind as I read about monads. Feel free to correct me whenever and wherever I am wrong.<p>Furthermore, I will mostly be using <code>TypeScript</code> to show a version of monad in its imperative form. So this is just a note that it will not be as powerful and as elegant as its "equivalence" or superior form in <code>Haskell</code>.<h2 id=introduction>Introduction</h2><p>In programming, we have to deal with a lot of complexities. In my experience, there are 2 different kinds of complexities:<ol><li><p>Business complexity. This is the complexity of the requirement that have been tasked to us developers.</p><li><p>Programming complexity. This is the complexity that comes from the implementation of said requirements. For example, take pointers. Requirements usually make no mention of performance/implementation.</p></ol><p>One thing about complexity is that they will always exist. We may be able to eliminate the second complexity; which we will attempt to later. However, the first part will always be there --- it is literally why we are here in the first place.<p>I think one of the biggest cause of complexity is the states. Our monkey brain is extremely bad at managing them (Or is it just me?). There some tools to help us narrow down the set of possible issues/states that we have to deal with. Types is one such tool and it is possibly the most popular and reliable static analysis tool.<p>The only thing that we can do is to abstract it away the complexity. Then we just pray that the abstraction doesn't break in a really awful manner down the line. At the end of the day, <em>someone</em> gotta pay for the complexity.<h2 id=we-begin-with-dynamic-types>We Begin with Dynamic Types</h2><p>Dynamic languages will "allow" us to write anything we like. I say in quotes because this is actually not true. The reason is that we most definitely do no want to write "anything we like". As I have said before, it is very hard for us human to keep a consistent flow of thought.<p>My gripe with untyped languge is that it allows you to do even the stupidest mistake. For example, consider the following JavaScript code,<pre class=language-javascript data-lang=javascript style=background-color:#2b303b;color:#c0c5ce;><code class=language-javascript data-lang=javascript><span style=color:#b48ead;>let </span><span style=color:#bf616a;>a </span><span>= "</span><span style=color:#a3be8c;>a</span><span>";
</span><span style=color:#b48ead;>let </span><span style=color:#bf616a;>b </span><span>= </span><span style=color:#d08770;>false</span><span>;
</span><span style=color:#b48ead;>let </span><span style=color:#bf616a;>c </span><span>= </span><span style=color:#bf616a;>a </span><span>+ </span><span style=color:#bf616a;>b</span><span>;
</span></code></pre><p>Does this make any sense? I find it to be extremely infuriating when my computer cannot tell me what it <em>already</em> knows. Another example is <code>C</code>'s <a href=https://en.cppreference.com/w/c/io/fprintf>printf</a>.<pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#b48ead;>const char </span><span>*pointer = "</span><span style=color:#a3be8c;>hello world</span><span>";
</span><span style=color:#bf616a;>printf</span><span>("</span><span style=color:#d08770;>%%</span><span style=color:#a3be8c;>p => </span><span style=color:#d08770;>%p</span><span style=color:#96b5b4;>\n</span><span>", pointer);
</span><span style=color:#bf616a;>printf</span><span>("</span><span style=color:#d08770;>%%</span><span style=color:#a3be8c;>s => </span><span style=color:#d08770;>%s</span><span style=color:#96b5b4;>\n</span><span>", pointer);
</span><span style=color:#bf616a;>printf</span><span>("</span><span style=color:#d08770;>%%</span><span style=color:#a3be8c;>d => </span><span style=color:#d08770;>%d</span><span style=color:#96b5b4;>\n</span><span>", pointer);
</span></code></pre><p>Compiling and executing the binary gets us,<pre class=language-bash data-lang=bash style=background-color:#2b303b;color:#c0c5ce;><code class=language-bash data-lang=bash><span style=color:#bf616a;>hbina@akarin:~/git/hbina.github.io$</span><span> clang ./static/programming_with_context/example_printf_program.c && </span><span style=color:#bf616a;>./a.out
</span><span style=color:#bf616a;>./static/programming_with_context/example_printf_program.c:8:27:</span><span> warning: format specifies type '</span><span style=color:#a3be8c;>int</span><span>' but the argument has type '</span><span style=color:#a3be8c;>const char *</span><span>' </span><span style=color:#b48ead;>[</span><span>-Wformat</span><span style=color:#b48ead;>]
</span><span>    </span><span style=color:#bf616a;>printf</span><span>("</span><span style=color:#a3be8c;>%%d => %d\n</span><span>", pointer);
</span><span>                   </span><span style=color:#bf616a;>~~</span><span>     ^</span><span style=color:#bf616a;>~~~~~~
</span><span>                   %</span><span style=color:#bf616a;>s
</span><span style=color:#bf616a;>1</span><span> warning generated.
</span><span>%</span><span style=color:#bf616a;>p</span><span> => </span><span style=color:#d08770;>0</span><span>x402004
</span><span>%</span><span style=color:#bf616a;>s</span><span> => hello world
</span><span>%</span><span style=color:#bf616a;>d</span><span> => </span><span style=color:#d08770;>4202500
</span></code></pre><p>Only the first 2 makes sense...but the 3rd one? Not so much --- but fortunately clang does warn us about this. Regardless, it still pains me that a computer is allowing me to make such mistakes. These examples are just for illustrative purpose, but imagine dealing with <code>C</code>'s <a href=https://en.cppreference.com/w/c/language/union>tagged union</a>.<p>I think dynamic languages is the perfect tool for writing small scripts. However, the moment you want the program to span for more than 2 files or when you want to refactor/enhance the functionality; you will start having issues or implicit conversions?<p>In my experience, what ended up happening is some sort of ad-hoc type-checking anyways.<ol><li><p>Perform a manual check/verification. You do this by going through all the possible states of the program to convince yourself that the function does what you think it does. Needless to say this is insanely hard to do. Most of the time, its just <em>assumed</em> that something works and hope for the best. When something does go bad, <em>then</em> we go take a look and fix it. This is obviously not ideal.</p><li><p>Another way you can narrow down the states (and to verify your assumptions) is to perform some kind of check. For example, we can do a type-guard IN JavaScript. This way we check that any given value is what you think it is.</p></ol><pre class=language-javascript data-lang=javascript style=background-color:#2b303b;color:#c0c5ce;><code class=language-javascript data-lang=javascript><span style=color:#b48ead;>if </span><span>(typeof </span><span style=color:#bf616a;>value </span><span>=== "</span><span style=color:#a3be8c;>string</span><span>") {
</span><span>  </span><span style=color:#65737e;>// Great! It's a string
</span><span>} </span><span style=color:#b48ead;>else </span><span>{
</span><span>  </span><span style=color:#65737e;>// Do something else...
</span><span>}
</span></code></pre><ol start=3><li>Write lots of test cases. Loads of them.</ol><h2 id=enter-types>Enter Types</h2><p>To me, type is just a way to constraint the possible states that a variable can take. If I annotated a variable as a <code>number</code>, then I don't have to think about it being anything other than a <code>number</code>. This alone removes a huge cognitive load from anyone attempting to understand the behavior of the program.<p>Additionally, types also provides you hint about the implementation of any given function. For example, a function that takes 2 <code>number</code>s and returning a <code>number</code> will probably do some sort of calculations on them. Given a function like,<pre class=language-typescript data-lang=typescript style=background-color:#2b303b;color:#c0c5ce;><code class=language-typescript data-lang=typescript><span style=color:#b48ead;>const </span><span style=color:#8fa1b3;>HighestBidder </span><span>= (</span><span style=color:#bf616a;>bids</span><span>: [String, number][]) -> [String, number] </span><span style=color:#b48ead;>=> </span><span>{...}
</span></code></pre><p>I can already expect what the function does. If I want to be extra sure and really understand the implementation, the function name and the types will guide me through it.<p>However, types alone is not powerful enough to constraint the possible states and especially unique/bad ones.<h2 id=function-values-consequence>Function + Values = Consequence</h2><p>Eventhough we have narrowed down a variable to just one type, some types can take on many different values with varying meanings. For example, if we have a type <code>number</code> it includes all the possible 64-bit floating points.<p>Therefore, we can think of a type as having a set of values. And within this set, the values are divided into what we consider as "normal values" and some "problematic values".<p>But, these values existing by itself isn't the problem. I can declare any values I want, <code>nullptr</code>, <code>NaN</code>, <code>-Inf</code> or whatever and if it's just sitting there not interacting with anything, it's by definition is doing nothing except maybe take up stack space.<p>However, applying functions to values have consequences.<p>The problem arises when we interact with these values using functions. When we write a function, we are attempting to express some idea of computation. The arguments type indicate what possible values the function can take and the result type indicate what possible values it will spit out.<p>Let's consider an addition function,<pre class=language-typescript data-lang=typescript style=background-color:#2b303b;color:#c0c5ce;><code class=language-typescript data-lang=typescript><span style=color:#b48ead;>const </span><span style=color:#8fa1b3;>addition </span><span>= (</span><span style=color:#bf616a;>a</span><span>: number, </span><span style=color:#bf616a;>b</span><span>: number): number </span><span style=color:#b48ead;>=> </span><span>{
</span><span>  </span><span style=color:#b48ead;>return </span><span style=color:#bf616a;>a </span><span>+ </span><span style=color:#bf616a;>b</span><span>;
</span><span>};
</span></code></pre><p>But we have a problem here. We are interacting with the whole set of possible values of <code>number</code>. And some of them are not as nice to work as we have discovered. What does <code>NaN + 3</code> means? What about <code>3 + -Inf</code>? All of these are values that we <em>really</em> don't care.<p>I mean sure, someone will come up and say they know every possible interactions by hand. But it's still silly to worry about that every single time I want to do anything meaningful. I am just trying to write an addition function here!<p>This is where the second kind of complexity that I mentioned before comes sneaking in. Most requirements most definitely do not include a specification for how to deal with <code>NaN</code> or floating point errors. Yet it is something that we have to consider.<p>One easy way to go around this is to,<pre class=language-typescript data-lang=typescript style=background-color:#2b303b;color:#c0c5ce;><code class=language-typescript data-lang=typescript><span style=color:#b48ead;>const </span><span style=color:#8fa1b3;>addition </span><span>= (</span><span style=color:#bf616a;>a</span><span>: number, </span><span style=color:#bf616a;>b</span><span>: number): number | undefined </span><span style=color:#b48ead;>=> </span><span>{
</span><span>  </span><span style=color:#b48ead;>if </span><span>(</span><span style=color:#bf616a;>a </span><span>=== </span><span style=color:#d08770;>NaN </span><span>|| </span><span style=color:#bf616a;>a </span><span>=== </span><span style=color:#d08770;>Infinity </span><span>|| </span><span style=color:#bf616a;>a </span><span>=== -</span><span style=color:#d08770;>Infinity </span><span style=color:#65737e;>/* and the rest */</span><span>) {
</span><span>    </span><span style=color:#b48ead;>return </span><span style=color:#d08770;>undefined</span><span>;
</span><span>  } </span><span style=color:#b48ead;>else </span><span>{
</span><span>    </span><span style=color:#b48ead;>return </span><span style=color:#bf616a;>a </span><span>+ </span><span style=color:#bf616a;>b</span><span>;
</span><span>  }
</span><span>};
</span></code></pre><p>At this point, you are pretty happy about the safety of this function. We are sure that any time we call this function, the result is a <em>number</em>. We are confident that the computation we are performing here are what we consider as "addition".<p>But then, a new requirement comes in and we need to implement a substraction function. Fine, we can just copy and paste the implementation before and replace <code>+</code> with <code>-</code>.<pre class=language-typescript data-lang=typescript style=background-color:#2b303b;color:#c0c5ce;><code class=language-typescript data-lang=typescript><span style=color:#b48ead;>const </span><span style=color:#8fa1b3;>substraction </span><span>= (</span><span style=color:#bf616a;>a</span><span>: number, </span><span style=color:#bf616a;>b</span><span>: number): number | undefined </span><span style=color:#b48ead;>=> </span><span>{
</span><span>  </span><span style=color:#b48ead;>if </span><span>(</span><span style=color:#bf616a;>a </span><span>=== </span><span style=color:#d08770;>NaN </span><span>|| </span><span style=color:#bf616a;>a </span><span>=== </span><span style=color:#d08770;>Infinity </span><span>|| </span><span style=color:#bf616a;>a </span><span>=== -</span><span style=color:#d08770;>Infinity </span><span style=color:#65737e;>/* and the rest */</span><span>) {
</span><span>    </span><span style=color:#b48ead;>return </span><span style=color:#d08770;>undefined</span><span>;
</span><span>  } </span><span style=color:#b48ead;>else </span><span>{
</span><span>    </span><span style=color:#b48ead;>return </span><span style=color:#bf616a;>a </span><span>- </span><span style=color:#bf616a;>b</span><span>;
</span><span>  }
</span><span>};
</span></code></pre><p>Then multiple new requirement comes in, multiplication, division, factorial... We will need to do this <em>every</em> single time. Even worse than that, we can clearly see that they are all awfully similar. Notice that the only thing that "matters" here is the binary operator. Just that 1 character.<p>Surely there's some way to abstract/pull out these common checks into a class.<h2 id=don-t-repeat-yourself>Don't Repeat Yourself</h2><p>Let's digress a bit and talk about function that accepts pointers as its argument. A pointer can take on many values, so the function itself has to deal with the states. From the function's point of view, the pointer could take on any values so it has to check if its <code>NULL</code> or not. This is bad because:<ol><li>We need to always do it.<li>We need to always do it right.<li>We need to pinky promise that we will do it all the time.</ol><p>It is simply nigh impossible to know when/where any given pointers are valid throughout its existence. From my experience, what ended up happening is that people create macros that will check for null pointers and panic otherwise. This macros would then be plastered around everywhere at the beginning of every function that uses pointers. Some of them are manually removed if the author is convinced enough that its not needed.<p>Can we do better? Aren't we taugh to pull out common abstraction into a function and reuse that instead?<h2 id=hide-behind-the-container>Hide Behind the Container</h2><p>It turns that there is a way to deal with all this repetitiveness. If you have ever taken a class in computer science or programming, you will most definitely have come across classes (or containers). The strategy is that we hide the values behind a container and the only way you can interact with the contained value is by passing it a function. Let's call this a <code>MaybeNumber</code>.<pre class=language-typescript data-lang=typescript style=background-color:#2b303b;color:#c0c5ce;><code class=language-typescript data-lang=typescript><span style=color:#b48ead;>class </span><span style=color:#ebcb8b;>MaybeNumber </span><span style=color:#eff1f5;>{
</span><span style=color:#eff1f5;>  </span><span style=color:#bf616a;>value</span><span>: </span><span style=color:#eff1f5;>number;
</span><span style=color:#eff1f5;>  </span><span style=color:#b48ead;>constructor</span><span>(</span><span style=color:#bf616a;>v</span><span>: </span><span style=color:#eff1f5;>number</span><span>) </span><span style=color:#eff1f5;>{
</span><span style=color:#eff1f5;>    </span><span style=color:#bf616a;>this</span><span style=color:#eff1f5;>.value </span><span>= </span><span style=color:#bf616a;>v</span><span style=color:#eff1f5;>;
</span><span style=color:#eff1f5;>  }
</span><span style=color:#eff1f5;>  </span><span style=color:#8fa1b3;>bind</span><span>(</span><span style=color:#8fa1b3;>f</span><span>: (</span><span style=color:#bf616a;>t</span><span>: </span><span style=color:#eff1f5;>number</span><span>) </span><span style=color:#b48ead;>=> </span><span style=color:#eff1f5;>MaybeNumber</span><span>): </span><span style=color:#eff1f5;>MaybeNumber {
</span><span style=color:#eff1f5;>    </span><span style=color:#b48ead;>if </span><span style=color:#eff1f5;>(
</span><span style=color:#eff1f5;>      </span><span style=color:#bf616a;>this</span><span style=color:#eff1f5;>.value </span><span>=== </span><span style=color:#d08770;>NaN </span><span>||
</span><span style=color:#eff1f5;>      </span><span style=color:#bf616a;>this</span><span style=color:#eff1f5;>.value </span><span>=== </span><span style=color:#d08770;>Infinity </span><span>||
</span><span style=color:#eff1f5;>      </span><span style=color:#bf616a;>this</span><span style=color:#eff1f5;>.value </span><span>=== -</span><span style=color:#d08770;>Infinity </span><span style=color:#65737e;>/* and the rest */
</span><span style=color:#eff1f5;>    ) {
</span><span style=color:#eff1f5;>      </span><span style=color:#b48ead;>return </span><span style=color:#bf616a;>this</span><span style=color:#eff1f5;>;
</span><span style=color:#eff1f5;>    } </span><span style=color:#b48ead;>else </span><span style=color:#eff1f5;>{
</span><span style=color:#eff1f5;>      </span><span style=color:#b48ead;>return </span><span style=color:#8fa1b3;>f</span><span style=color:#eff1f5;>(</span><span style=color:#bf616a;>this</span><span style=color:#eff1f5;>.value);
</span><span style=color:#eff1f5;>    }
</span><span style=color:#eff1f5;>  }
</span><span style=color:#eff1f5;>}
</span></code></pre><p>Let's go through the class slowly. First, we note that the class contains 1 member variable, <code>value</code> which contains the <code>number</code> that we want to hide. Then we have a simply constructor to create this container from a pure <code>number</code>. Lastly, we have the <code>bind</code> function that takes a <code>number</code> and returns the <code>MaybeNumber</code>. You might be thinking, why does it return a <code>MaybeNumber</code> and not a I<code>number</code>?<p>This is a deliberate choice because we want to force the user of this value to always deal with this class and it enables nice composition ala <code>Promise</code>s.<p>First, lets deal with the fact that the signature requires us to return a <code>MaybeNumber</code>. Does this mean that we need to reimplement all the functions that didn't use <code>MaybeNumber</code> into one? Fear not, for we can lift these functions.<p>We can simply "lift" any given function using the unit function. <code>lift</code> takes any function from <code>T -> number</code> into <code>T -> MaybeNumber</code><pre class=language-typescript data-lang=typescript style=background-color:#2b303b;color:#c0c5ce;><code class=language-typescript data-lang=typescript><span style=color:#b48ead;>type </span><span>BindArg = (</span><span style=color:#bf616a;>a</span><span>: number) </span><span style=color:#b48ead;>=> </span><span>number;
</span><span style=color:#b48ead;>type </span><span>BindResult = (</span><span style=color:#bf616a;>a</span><span>: number) </span><span style=color:#b48ead;>=> </span><span>MaybeNumber;
</span><span style=color:#b48ead;>function </span><span style=color:#8fa1b3;>lift</span><span>(</span><span style=color:#bf616a;>f</span><span>: BindArg): BindResult {
</span><span>  </span><span style=color:#b48ead;>return </span><span>(</span><span style=color:#bf616a;>a</span><span>) </span><span style=color:#b48ead;>=> </span><span style=color:#8fa1b3;>unit</span><span>(</span><span style=color:#8fa1b3;>f</span><span>(</span><span style=color:#bf616a;>a</span><span>));
</span><span>}
</span></code></pre><p>And so if we have functions like,<pre class=language-typescript data-lang=typescript style=background-color:#2b303b;color:#c0c5ce;><code class=language-typescript data-lang=typescript><span style=color:#b48ead;>const </span><span style=color:#8fa1b3;>times2 </span><span>= (</span><span style=color:#bf616a;>v</span><span>: number) </span><span style=color:#b48ead;>=> </span><span style=color:#bf616a;>v </span><span>* </span><span style=color:#d08770;>2</span><span>;
</span><span style=color:#b48ead;>const </span><span style=color:#8fa1b3;>adds2 </span><span>= (</span><span style=color:#bf616a;>v</span><span>: number) </span><span style=color:#b48ead;>=> </span><span style=color:#bf616a;>v </span><span>+ </span><span style=color:#d08770;>2</span><span>;
</span></code></pre><p>We can simply lifts them and use them like so,<pre class=language-typescript data-lang=typescript style=background-color:#2b303b;color:#c0c5ce;><code class=language-typescript data-lang=typescript><span style=color:#b48ead;>const </span><span style=color:#bf616a;>times2M </span><span>= </span><span style=color:#8fa1b3;>lift</span><span>(</span><span style=color:#bf616a;>times2</span><span>);
</span><span style=color:#b48ead;>const </span><span style=color:#bf616a;>adds2M </span><span>= </span><span style=color:#8fa1b3;>lift</span><span>(</span><span style=color:#bf616a;>adds2</span><span>);
</span><span>
</span><span style=color:#b48ead;>const </span><span style=color:#bf616a;>b </span><span>= </span><span style=color:#8fa1b3;>unit</span><span>(</span><span style=color:#d08770;>10</span><span>);
</span><span style=color:#b48ead;>const </span><span style=color:#bf616a;>b2 </span><span>= </span><span style=color:#bf616a;>b</span><span>.</span><span style=color:#8fa1b3;>bind</span><span>(</span><span style=color:#bf616a;>times2M</span><span>);
</span><span style=color:#b48ead;>const </span><span style=color:#bf616a;>b2M </span><span>= </span><span style=color:#bf616a;>b2</span><span>.</span><span style=color:#8fa1b3;>bind</span><span>(</span><span style=color:#bf616a;>times2M</span><span>).</span><span style=color:#8fa1b3;>bind</span><span>(</span><span style=color:#bf616a;>adds2M</span><span>).</span><span style=color:#8fa1b3;>bind</span><span>(</span><span style=color:#bf616a;>times2M</span><span>).</span><span style=color:#8fa1b3;>bind</span><span>(</span><span style=color:#bf616a;>adds2M</span><span>);
</span></code></pre><h2 id=enter-monads>Enter Monads</h2><p>In my (humble) opinion, monads is just a way to express computations as types. Computations produces result and instead of actually using the result, we just provide a function <code>f</code> to the type that performs the computation itself.<p>A monad is not any specific type, it is more like an instance. In <code>Haskell</code>, <code>Monad</code> is a typeclass defined as,<pre class=language-haskell data-lang=haskell style=background-color:#2b303b;color:#c0c5ce;><code class=language-haskell data-lang=haskell><span style=color:#b48ead;>class  </span><span style=color:#ebcb8b;>Monad </span><span style=color:#bf616a;>m  </span><span style=color:#b48ead;>where
</span><span>    </span><span style=color:#65737e;>-- The () indicates that this is an infix operator, so it closely resembles a class having a method.
</span><span>    </span><span style=color:#8fa1b3;>(>>=)  </span><span style=color:#b48ead;>:: </span><span style=color:#bf616a;>m a </span><span style=color:#b48ead;>-></span><span> (</span><span style=color:#bf616a;>a </span><span style=color:#b48ead;>-> </span><span style=color:#bf616a;>m b</span><span>) </span><span style=color:#b48ead;>-> </span><span style=color:#bf616a;>m b
</span><span>    </span><span style=color:#8fa1b3;>return </span><span style=color:#b48ead;>:: </span><span style=color:#bf616a;>a </span><span style=color:#b48ead;>-> </span><span style=color:#bf616a;>m a
</span></code></pre><p>TypeScript cannot express this concept but let's pretend we have one that can. In this hypothetical TypeScript, it could be written like this,<pre class=language-typescript data-lang=typescript style=background-color:#2b303b;color:#c0c5ce;><code class=language-typescript data-lang=typescript><span style=color:#b48ead;>export interface </span><span>Monad&LTT> {
</span><span>  </span><span style=color:#65737e;>// also called unit
</span><span>  </span><span style=color:#b48ead;>static </span><span style=color:#8fa1b3;>return</span><span>(</span><span style=color:#bf616a;>t</span><span>: T): Monad&LTT>;
</span><span>  </span><span style=color:#65737e;>// The monad's >== function is also called bind
</span><span>  </span><span style=color:#8fa1b3;>bind</span><span>(</span><span style=color:#8fa1b3;>f</span><span>: (</span><span style=color:#bf616a;>t</span><span>: T) </span><span style=color:#b48ead;>=> </span><span>Monad&LTR>): Monad&LTR>;
</span><span>}
</span></code></pre><p>And any class <code>M&LTT></code> that implements <code>Monad&LTT></code> (satisfying the monadic laws which we will not cover here) is a monad. What is so powerful about this? Well, it enables you to abstract one computation from another.<p>Let's look at some example.<h3 id=maybe-monad>Maybe Monad</h3><p>The maybe monad is used to represent a "computation" or "behavior" where a value may or may not exist. Let's implement it in our imaginary TypeScript,<pre class=language-typescript data-lang=typescript style=background-color:#2b303b;color:#c0c5ce;><code class=language-typescript data-lang=typescript><span style=color:#65737e;>// An enum to express existence of a value
</span><span>
</span><span style=color:#b48ead;>type </span><span>Option&LTT> =
</span><span>  | {
</span><span>      </span><span style=color:#bf616a;>kind</span><span>: "</span><span style=color:#a3be8c;>Some</span><span>";
</span><span>      </span><span style=color:#bf616a;>value</span><span>: T;
</span><span>    }
</span><span>  | {
</span><span>      </span><span style=color:#bf616a;>kind</span><span>: "</span><span style=color:#a3be8c;>Nothing</span><span>";
</span><span>    };
</span><span>
</span><span style=color:#65737e;>// Helper functions
</span><span>
</span><span style=color:#b48ead;>const </span><span style=color:#8fa1b3;>createSome </span><span>= &LTT>(</span><span style=color:#bf616a;>t</span><span>: T) </span><span style=color:#b48ead;>=> </span><span>{
</span><span>    kind : "</span><span style=color:#a3be8c;>Some</span><span>",
</span><span>    value : </span><span style=color:#bf616a;>t
</span><span>}
</span><span>
</span><span style=color:#b48ead;>const </span><span style=color:#8fa1b3;>createNone </span><span>= &LTT>() </span><span style=color:#b48ead;>=> </span><span>{
</span><span>    kind : "</span><span style=color:#a3be8c;>Nothing</span><span>",
</span><span>}
</span><span>
</span><span style=color:#b48ead;>class </span><span style=color:#ebcb8b;>Maybe</span><span style=color:#eff1f5;>&LTOption&LTT>> </span><span style=color:#b48ead;>implements </span><span style=color:#a3be8c;>Monad</span><span style=color:#eff1f5;>&LTOption&LTT>> {
</span><span style=color:#eff1f5;>    </span><span style=color:#bf616a;>t </span><span>: </span><span style=color:#eff1f5;>Option&LTT>
</span><span style=color:#eff1f5;>    </span><span style=color:#b48ead;>static </span><span style=color:#8fa1b3;>return</span><span>(</span><span style=color:#bf616a;>t</span><span>: </span><span style=color:#eff1f5;>Option&LTT></span><span>)</span><span style=color:#eff1f5;> => new </span><span style=color:#8fa1b3;>Maybe</span><span>(</span><span style=color:#bf616a;>t</span><span>)
</span><span style=color:#eff1f5;>    </span><span style=color:#8fa1b3;>bind</span><span>(</span><span style=color:#8fa1b3;>f</span><span>: (</span><span style=color:#bf616a;>t</span><span>: </span><span style=color:#eff1f5;>T</span><span>) </span><span style=color:#b48ead;>=> </span><span style=color:#eff1f5;>Maybe&LTOption&LTR>></span><span>): </span><span style=color:#eff1f5;>Maybe&LTOption&LTR>> {
</span><span style=color:#eff1f5;>        </span><span style=color:#b48ead;>if </span><span style=color:#eff1f5;>(</span><span style=color:#bf616a;>this</span><span style=color:#eff1f5;>.</span><span style=color:#bf616a;>t</span><span style=color:#eff1f5;>.</span><span style=color:#bf616a;>kind </span><span>=== "</span><span style=color:#a3be8c;>Nothing</span><span>"</span><span style=color:#eff1f5;>) {
</span><span style=color:#eff1f5;>            </span><span style=color:#b48ead;>return </span><span style=color:#8fa1b3;>createNone</span><span style=color:#eff1f5;>();
</span><span style=color:#eff1f5;>        } </span><span style=color:#b48ead;>else </span><span style=color:#eff1f5;>{
</span><span style=color:#eff1f5;>            </span><span style=color:#b48ead;>return </span><span style=color:#8fa1b3;>f</span><span style=color:#eff1f5;>(</span><span style=color:#bf616a;>this</span><span style=color:#eff1f5;>.</span><span style=color:#bf616a;>t</span><span style=color:#eff1f5;>.value);
</span><span style=color:#eff1f5;>        }
</span><span style=color:#eff1f5;>    }
</span><span style=color:#eff1f5;>}
</span></code></pre><p>And using it looks like,<pre class=language-typescript data-lang=typescript style=background-color:#2b303b;color:#c0c5ce;><code class=language-typescript data-lang=typescript><span style=color:#65737e;>// Here we implement the behavior that division by 0 is bad.
</span><span style=color:#b48ead;>const </span><span style=color:#8fa1b3;>safeAddition </span><span>= (</span><span style=color:#bf616a;>a</span><span>: PositiveInteger, </span><span style=color:#bf616a;>b</span><span>: PositiveInteger) </span><span style=color:#b48ead;>=> </span><span>{
</span><span>  </span><span style=color:#b48ead;>if </span><span>(</span><span style=color:#bf616a;>MAX_POSITIVE_INT </span><span>- </span><span style=color:#bf616a;>b </span><span>> </span><span style=color:#bf616a;>a</span><span>) {
</span><span>      </span><span style=color:#65737e;>// Overflow, returns none
</span><span>      </span><span style=color:#b48ead;>return </span><span>Maybe::</span><span style=color:#b48ead;>return</span><span>(</span><span style=color:#8fa1b3;>createNone</span><span>());
</span><span>  } </span><span style=color:#b48ead;>else </span><span>{
</span><span>      </span><span style=color:#65737e;>// Addition does not overflow
</span><span>      </span><span style=color:#b48ead;>return </span><span>Maybe::</span><span style=color:#b48ead;>return</span><span>(</span><span style=color:#8fa1b3;>createSome</span><span>(</span><span style=color:#bf616a;>a </span><span>/ </span><span style=color:#bf616a;>b</span><span>));
</span><span>  }
</span><span>}
</span></code></pre><pre class=language-typescript data-lang=typescript style=background-color:#2b303b;color:#c0c5ce;><code class=language-typescript data-lang=typescript><span style=color:#65737e;>// Here we implement a funct
</span><span style=color:#b48ead;>const </span><span style=color:#8fa1b3;>multiplication </span><span>= (
</span><span>  </span><span style=color:#bf616a;>a</span><span>: Maybe&LTOption&LTT>>,
</span><span>  </span><span style=color:#bf616a;>b</span><span>: Maybe&LTOption&LTT>>
</span><span>): Maybe&LTOption&LTT>> </span><span style=color:#b48ead;>=> </span><span>{
</span><span>  </span><span style=color:#b48ead;>return </span><span style=color:#bf616a;>a</span><span>.</span><span style=color:#8fa1b3;>bind</span><span>((</span><span style=color:#bf616a;>l</span><span>) </span><span style=color:#b48ead;>=>
</span><span>    </span><span style=color:#bf616a;>b</span><span>.</span><span style=color:#8fa1b3;>bind</span><span>((</span><span style=color:#bf616a;>r</span><span>) </span><span style=color:#b48ead;>=> </span><span>(</span><span style=color:#bf616a;>l </span><span>=== </span><span style=color:#d08770;>1 </span><span>?
</span><span>      </span><span style=color:#bf616a;>r </span><span>: </span><span style=color:#bf616a;>r </span><span>=== </span><span style=color:#d08770;>1 </span><span>? </span><span style=color:#bf616a;>l </span><span>: </span><span style=color:#8fa1b3;>safeAddition</span><span>(</span><span style=color:#bf616a;>l</span><span>, </span><span style=color:#bf616a;>l</span><span>).</span><span style=color:#8fa1b3;>bind</span><span>((</span><span style=color:#bf616a;>v</span><span>) </span><span style=color:#b48ead;>=>
</span><span>        </span><span style=color:#8fa1b3;>multiplication</span><span>(
</span><span>          </span><span style=color:#bf616a;>Maybe</span><span>::</span><span style=color:#8fa1b3;>return</span><span>(</span><span style=color:#8fa1b3;>createSome</span><span>(</span><span style=color:#bf616a;>v</span><span>)),
</span><span>          </span><span style=color:#bf616a;>Maybe</span><span>::</span><span style=color:#8fa1b3;>return</span><span>(</span><span style=color:#8fa1b3;>createSome</span><span>(</span><span style=color:#bf616a;>r </span><span>- </span><span style=color:#d08770;>1</span><span>)))))
</span><span>    ));
</span><span>};
</span></code></pre><p>I am going to be honest, it doesn't look as great. This is mostly because you need to jump through lot of syntax to do anything meaningful. This is why Haskell does away with almost all syntax to function application (the only thing that matters really is the position). This makes Haskell's implementation of this concept a lot more compact.<p>One thing to notice is that we didn't have to perform any check on the behavior that "division by 0 is bad" anywhere in <code>multiplication</code>. The error handling is done automatically and we only concern ourselves with the details to implement multiplication.<h3 id=implement-allcombinations>Implement allCombinations</h3><h2 id=list-monad>List Monad</h2><h2 id=state-monad>State Monad</h2></div><section><hr><p>[<a href=/>Home</a>]<p>My resume <a href=/resume.html>here</a>.<p>Source code available <a href=https://github.com/hbina/hbina.github.io>here</a>. You can raise an issue if ... you have an issue with it.